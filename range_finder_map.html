<!DOCTYPE html>
<html>
<head>
  <title>Range Finder Map — Full Wrap</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    html,body{height:100%;margin:0}
    #map{height:88vh;width:100%}
    .ctl{font:14px/1.4 Arial;padding:8px 12px}
    .ctl input{width:110px;margin-right:6px}
  </style>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.geodesic/Leaflet.Geodesic.min.js"></script>
</head>
<body>
  <h2 class="ctl">Range Finder Map</h2>
  <div id="map"></div>
  <div class="ctl">
    Lat <input id="lat"  type="number" step="any" value="38.573315">
    Lon <input id="lon"  type="number" step="any" value="-109.549839">
    Bearing° <input id="brg" type="number" value="90">
    Distance (mi) <input id="dst" type="number" value="1000">
    <button onclick="draw()">Draw Line</button>
    <span id="pct"></span>
  </div>

<script>
const R_MI = 3958.8, EARTH = 24901;
const toRad = d => d*Math.PI/180,  toDeg = r => r*180/Math.PI;
const qp = n => new URLSearchParams(location.search).get(n);

// ----- map -----------------------------
const map = L.map('map', {
  center:[38.573315,-109.549839],
  zoom:3,
  minZoom:2,
  maxZoom:7,
  worldCopyJump:false,
});

L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution:'&copy; OpenStreetMap contributors',
  noWrap:true                     // single world copy only
}).addTo(map);

let arcGroup;
function destination(lat,lon,brg,dist){
  const δ=dist/R_MI, θ=toRad(brg), φ1=toRad(lat), λ1=toRad(lon);
  const φ2=Math.asin(Math.sin(φ1)*Math.cos(δ)+Math.cos(φ1)*Math.sin(δ)*Math.cos(θ));
  const λ2=λ1+Math.atan2(Math.sin(θ)*Math.sin(δ)*Math.cos(φ1),Math.cos(δ)-Math.sin(φ1)*Math.sin(φ2));
  return [toDeg(φ2), ((toDeg(λ2)+540)%360)-180];
}

function geodesicSeg(a,b){
  try{
    return L.geodesic([[a,b]],{steps:128,weight:3,color:'blue',wrap:false});
  }catch(e){
    return L.polyline([a,b],{color:'blue'});
  }
}

function draw(){
  const lat=+latEl.value, lon=+lonEl.value, brg=+brgEl.value, dist=+dstEl.value;
  if(arcGroup) map.removeLayer(arcGroup);

  const start=[lat,lon];
  const end=destination(lat,lon,brg,dist);
  const dLon=Math.abs(lon-end[1]);

  let layers=[];
  if(dLon<=180){
      layers.push(geodesicSeg(start,end));
  }else{
      // split: first half straight to dateline, second half wrapped
      const half=destination(lat,lon,brg,dist/2);
      const mid=[half[0], (half[1]>0)?179.999:-179.999];
      layers.push(geodesicSeg(start,mid));
      const mid2=[mid[0], mid[1]>0?-180+ (mid[1]-179.999):180+ (mid[1]+179.999)];
      layers.push(geodesicSeg(mid2,end));
  }
  arcGroup=L.layerGroup(layers).addTo(map);
  map.fitBounds(arcGroup.getBounds(),{padding:[20,20]});
  pct.textContent=' — '+(dist/EARTH*100).toFixed(2)+'% around Earth';
}

const latEl=lat, lonEl=lon, brgEl=brg, dstEl=dst, pct=document.getElementById('pct');
window.addEventListener('DOMContentLoaded',()=>{const d=qp('distance');if(d) dstEl.value=d;draw();});
</script>
</body>
</html>
